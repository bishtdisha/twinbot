from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, validator
import logging
import traceback
from datetime import datetime
import os
from typing import Optional
import uvicorn
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Import your main query-processing logic
from twinbot_workflow import run_twinbot

# Initialize FastAPI app
app = FastAPI(
    title="TwinBot API",
    description="SCADA System Query Processing API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Enable CORS (allow all origins for now)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Setup logging to file and console
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('twinbot_api.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Input model: what the API will accept
class AskRequest(BaseModel):
    question: str = Field(..., description="User's question")
    token: Optional[str] = Field(None, description="User access token")
    customerId: Optional[str] = Field(None, description="Thingsboard customer ID")

    # Validation to ensure question is not just empty or whitespace
    @validator('question')
    def validate_question(cls, v):
        if not v.strip():
            raise ValueError('Question cannot be empty or just whitespace')
        return v.strip()

# Output model: what the API will return
class AskResponse(BaseModel):
    result: str = Field(..., description="Answer from bot")

# Main API endpoint for TwinBot
@app.post("/ask",
          response_model=AskResponse,
          responses={
              400: {"description": "Bad Request"},
              500: {"description": "Internal Server Error"}
          },
          tags=["TwinBot"])
async def process_ask(request: AskRequest):
    """
    Accepts a user question and returns a response generated by TwinBot.
    Request must include: question (required), token and customerId (optional).
    """
    try:
        logger.info(f"Processing question from customer {request.customerId or 'anonymous'}: {request.question}")

        # Call the TwinBot logic to generate a response
        response_text = run_twinbot(request.question)

        # Return the response in expected format
        return AskResponse(result=response_text)

    except Exception as e:
        # Log any unexpected errors
        error_trace = traceback.format_exc()
        logger.error(f"Error processing question: {str(e)}\n{error_trace}")

        # Return generic error to client
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while processing your query"
        )

# Entry point for running this as a script
if __name__ == '__main__':
    # Read environment configuration or use defaults
    host = os.getenv('API_HOST', '0.0.0.0')
    port = int(os.getenv('API_PORT', 8883))
    reload = os.getenv('API_RELOAD', 'False').lower() == 'true'

    logger.info(f"Starting TwinBot API server on {host}:{port}")
    logger.info(f"Reload mode: {reload}")
    logger.info(f"API Documentation available at: http://{host}:{port}/docs")

    # Start the Uvicorn ASGI server
    uvicorn.run("twinbot_api:app", host=host, port=port, reload=reload, access_log=True)